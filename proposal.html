<p>Proposal Title: BooleanScorer should sometimes be used for MUST clauses in Lucene</p>
<p>Student Name: Da Huang</p>
<p>Student E-mail: dhuang.cn@gmail.com</p>
<p>Student Mobile: +8613718862905</p>
<p>Organization/Project: The Apache Software Foundation (ASF)
<p>Assigned Mentor:</p>


<h2>Introduction to My Proposal</h2>
<p>Boolean Query is one of the most important types of query in an Information Retrieval System. Lucene has done several optimizations for that. The kernel modular to implement Boolean Query in lucene is <b>Scorer</b>, which can not only score a document, but also provide methods for collecting Hit Documents. There are mainly two Scorers, <b>BooleanScorer</b> and <b>BooleanScorer2</b> (Their natures can be found in <a href='#table1'>Table 1</a>), to deal with Boolean Query on current trunk. The class BooleanQuery would choose one of them as the scorer returning to the its caller.</p>
<p>Today lucene <b>only</b> uses BooleanScorer if the query consists of SHOULD and MUST_NOT. If there is one or more MUST clauses lucene always uses BooleanScorer2. But such way to make the choice is too easy and naive. What I would like to do in this project is to develop a more clever way for BooleanQuery to choose which Scorer to be uses.</p>
<p>However, the development would be not be so easy, some Scorers have to be improved to fit the new way.</p>

<h2>Project Goals</h2>
<p>The project shall deliver four components as follows:</p>
<p class=sub1>1) BooleanScorer which resupports MUST clause.</p>
<p class=sub1>2) A better rule for BooleanQuery to choose Scorer.</p>
<p class=sub1>3) A better <b>rewrite</b> method in BooleanQuery.</p>
<!--<p class=sub1>4) Revelant Javadocs and report.-->
<!--<p>Besides, <i>A more complete BooleanScorer which can be as Mid-Level Scorer</i> may be delivered.-->

<p class=sub1>4) A more complete BooleanScorer which can be as Mid-Level Scorer.</p>
<p>Revelant Javadoc and report shall be written for the components above.</p>

<h3>Quantifiable Results for the Apache Community</h3>
<p class=sub1>1) Faster BooleanQuery for Lucene.</p>
<p class=sub1>2) .</p>
<p class=sub1>3) .</p>
<p class=sub1>4) .</p>


<h2>Detailed Description</h2>
<h3>BooleanScorer vs. BooleanScorer2</h3>
<div class='figure_div'>
<div id='table1' class='tag'>Table 1.&nbsp;&nbsp;BooleanScorer vs. BooleanScorer2 on current lucene trunk</div>
<table border='1'>
<tr><th>Scorer Name</th>
<th>Usability</th><th>Disjunction Query</th><th>Conjunction Query</th>
<th>MUST Clause</th>
</tr>
<tr><th>BooleanScorer</th>
<td>As Top Scorer Only</td><td>Faster</td><td>Slower</td><td>Used to, Not Now</td>
</tr>
<tr><th>BooleanScorer2</th>
<td>No Level Limitation</td><td>Slower</td><td>Faster</td><td>Yes</td>
</tr>
</table>
</div>
<p>Table 1 illustrates some important natures of BooleanScorer and BooleanScorer2 on the current lucene trunk. The great difference between these two Scorer is due to their different ideas on implementation:
</p>
<p class=sub1>1) BooleanScorer is implemented by using an array to score windows of 2K. </p>

<h2>Schedule</h2>
<p> My schedule is showed on Table 2.</p>
<div class='figure_div'>
<div class='tag'>Table 2.&nbsp;&nbsp;Schedule</div>
<table border='1' style='text-align:center;'>
<tr><th>Timeline</th><th>Tasks</th></tr>
<tr>
<td>April 22 - May 16</td>
<td class='paragraph_td'>
<p>- Get to know the code and the community.</p>
<p>- Discuss with the mentor about some details on the code.</p>
<p>- Check the plan to go right.</p>
</td></tr>
<tr>
<td>May 19 - May 24</td>
<td class='paragraph_td'>
<p>- Analyze the requirements of a general BOW ranking framework.</p>
</td></tr>
<tr>
<td>May 25 - May 31</td>
<td class='paragraph_td'>
<p>- Verify if all data is available in the Lucene index. Add what is missing.</p>
</td></tr>
<tr>
<td>June 1 - June 20</td>
<td class='paragraph_td'>
<p>- Define and implement the new scoring class hierarchy.</p>
<p>- Identify which parts of the code requires refactoring to comply with the new architecture; refactor.</p>
</td></tr>
<tr>
<td>June 18 - June 27</td>
<td class='paragraph_td'>
<p>- Mid-term evaluations.</p>
</td></tr>
<tr>
<td>June 28 - July 19</td>
<td class='paragraph_td'>
<p>- Convert the Lucene VSM ranking algorithm to the new architecture.</p>
<p>- Test the new VSM implementation and validate it against the old one.</p>
</td></tr>
<tr>
<td>July 20 - July 31</td>
<td class='paragraph_td'>
<p>- Implement the configuration interface.</p>
</td></tr>
<tr>
<td>August 1 - August 10</td>
<td class='paragraph_td'>
<p>- Implement and test the BM25, BM25F and DFR ranking schemes.</p>
</td></tr>
<tr>
<td>August 16 - August 21</td>
<td class='paragraph_td'>
<p>- scrub code, write tests, improve documentation, etc.</p>
</td></tr>
<tr>
<td>August 22 - August 23</td>
<td class='paragraph_td'>
<p>- submitting required code samples to Google. </p>
</td></tr>
</table>
</div>


<h2>About Me</h2>
<p>I am studying for my Master Degree in Peking University, where I am majoring in Search Engine &amp; Web Mining. In this term, I am also trying to build a search engine with C++. You can fetch the newest version of my code from <a href='https://github.com/Da-Huang/Search-Engine'>https://github.com/Da-Huang/Search-Engine</a>.</p>

<p>You can know more about me on <a href=http://www.linkedin.com/profile/view?id=308789048 target='_blank'>http://www.linkedin.com/profile/view?id=308789048</a>.</p>


<!-- CSS -->
<style type='text/css'>
* {
	font-family:monospace;
    text-align:justify;  
	text-justify:distribute-all-lines;
}
td,th {
	text-align:center;
	padding-left:10px;
	padding-right:10px;
}
div.tag {
	text-align:center;
	font-weight:bold;
}
td>p {
	margin:5px;
}
td.paragraph_td {
	text-align:left;
}
div.figure_div {
	display:table;
}
p.sub1 {
	text-indent:2em;
	margin:5px;
}

</style>
