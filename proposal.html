<h1>LUCENE-4396: BooleanScorer should sometimes be used for MUST clauses</h1>
<p>Today Lucene only uses BooleanScorer if the query consists of SHOULD and MUST_NOT. If there is one or more MUST clauses lucene always uses BooleanScorer2. But it is suspected that unless the MUST clauses have very low hit count compared to the other clauses, that BooleanScorer would perform better than BooleanScorer2. The most challenging part might be the heuristics on when to use which.</p>
<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>

<body style='font-family:monospace;text-align:justify;text-justify:distribute-all-lines;'>
<p>Proposal Title: BooleanScorer should sometimes be used for MUST clauses in Lucene</p>
<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>
<p>Student Name: Da Huang</p>
<p>Student E-mail: dhuang.cn@gmail.com</p>
<p>Student Mobile: +8613718862905</p>
<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>
<p>Organization/Project: The Apache Software Foundation (ASF)
<p>Assigned Mentor: Michael McCandless</p>

<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>

<h2>Introduction to the Project</h2>
<p><b>BooleanQuery</b> is one of the most important types of query in an Information Retrieval System. Lucene has done several optimizations for that. The kernel modular to implement BooleanQuery in lucene is <b>Scorer</b>, which can not only score a document, but also provide methods for collecting hit documents. There are mainly two Scorers, <b>BooleanScorer</b> and <b>BooleanScorer2</b> (Their natures can be found in <a href='#table1'>Table 1</a>), to deal with BooleanQuery on current trunk. The class BooleanQuery would choose one of them as the scorer returning to the its caller.</p>
<p>Today lucene <b>only</b> uses BooleanScorer if the query consists of SHOULD and MUST_NOT. If there is one or more MUST clauses lucene always uses BooleanScorer2. But such way to make the choice is too easy and naive. What I would like to do in this project is to develop a more clever way for BooleanQuery to choose which Scorer to be uses.</p>
<p>The key to implementing the project is to make <b>BooleanScorer</b> support MUST clause, and then check the influence of MUST clause on BooleanScorer's speed by testing.</p>

<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>

<h2>Project Goals</h2>
<p>The project shall deliver four components as follows:</p>
<p class='sub1' style='text-indent:2em;margin:5px'>1) A mechanism which makes BooleanScorer support MUST clauses friendly ie. skipping the posting list trickily.</p>
<p class='sub1' style='text-indent:2em;margin:5px'>2) A more complete BooleanScorer which can act as Sub-Scorer in the case where at least one MUST clause is present.</p>
<p class='sub1' style='text-indent:2em;margin:5px'>3) A better rule for BooleanQuery to choose Scorer.</p>
<p class='sub1' style='text-indent:2em;margin:5px'>4) Revelant Javadocs and reports.</p>

<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>

<h2>Quantifiable Results for the Apache Community</h2>
<p class='sub1' style='text-indent:2em;margin:5px'>1) More efficient and powerful BooleanQuery for Apache Lucene.</p>
<!--<p class='sub1' style='text-indent:2em;margin:5px'>2) More powerful and efficient BooleanScorer which supports .</p>
-->
<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>

<h2>Project Details</h2>
<h3>BooleanScorer vs. BooleanScorer2</h3>
Beforing getting down to the optimization, I would like analyze the two Scorers first.
<div class='table_div' style='display:table'>
<div id='table1' class='tag' style='text-align:center;font-weight:bold;'>Table 1.&nbsp;&nbsp;BooleanScorer vs. BooleanScorer2 on current lucene trunk</div>
<table style='border:1px solid'>
<tr><th style='border:1px solid;'>Scorer</th>
<th style='border:1px solid;'>Usability</th><th style='border:1px solid;'>Disjunction Query</th><th style='border:1px solid;'>Conjunction Query</th>
<th style='border:1px solid;'>MUST Clause</th>
</tr>
<tr><th style='border:1px solid;'>BooleanScorer</th>
<td style='border:1px solid;text-align:center;padding-left:10px;padding-right:10px'>As Top Scorer Only</td><td style='border:1px solid;text-align:center;padding-left:10px;padding-right:10px'>Faster</td><td style='border:1px solid;text-align:center;padding-left:10px;padding-right:10px'>Not Supported Now</td><td style='border:1px solid;text-align:center;padding-left:10px;padding-right:10px'>Used to, Not Now</td>
</tr>
<tr><th style='border:1px solid;'>BooleanScorer2</th>
<td style='border:1px solid;text-align:center;padding-left:10px;padding-right:10px'>No Level Limitation</td><td style='border:1px solid;text-align:center;padding-left:10px;padding-right:10px'>Slower</td><td style='border:1px solid;text-align:center;padding-left:10px;padding-right:10px'>Fast</td><td style='border:1px solid;text-align:center;padding-left:10px;padding-right:10px'>Yes</td>
</tr>
</table>
</div>
<p>Table 1 illustrates some important natures of BooleanScorer and BooleanScorer2 on the current lucene trunk. The great difference between these two Scorer is due to their different ideas on implementation:</p>
<p class='sub1' style='text-indent:2em;margin:5px'>1) BooleanScorer is implemented by using an array to score windows of 2K. This way can make Disjunction Query faster, but leave the docIDs out of order as result. Thus, BooleanScorer can <b>only</b> act as Top Scorer.</p>
<p class='sub1' style='text-indent:2em;margin:5px'>2) BooleanScorer2 is implemented in a much more "traditional" way. That is merging the Disjunction Query with a heap.</p>
<p>In a conclusion, BooleanScorer applies a tricky algorithm to make Disjunction Query faster, but the algorithm makes the BooleanScorer can <b>only</b> act as Top Scorer and unsuitable for queries with MUST clauses.</p>
<p>In this project, I would focus on solving the MUST clauses problem first. Then, it could be found that, with the method used to solve the first problem, the Top Scorer only problem can naturally be solved in the case where at least one MUST clause is present.</p>

<!--<p>As for the Top Scorer only problem, it is not a severe one, because the top level of a boolean query is its main costly part. Further more, we can convert some costly parts of a boolean query to its top level, by rewriting it. Thus, I will pay most attention to solving the MUST clauses problem.</p>
<p>However, it seems that Top Scorer only problem can be solved naturally, after MUST clauses is supported in BooleanScorer.</p>-->

<h3 id='part2'>Make BooleanScorer Support MUST Clause</h3>
<p>In order to implement this function, the following problem should be figured out:</p>
<h4>1) How to support MUST clauses in BooleanScorer?</h4>
<div class='h4_content'>
<p>Actually, the original design of BooleanScorer on last trunk can support no more than 32 MUST clauses. This is because it uses a 32-bit value, <i>requiredMask</i>, to record which MUST clauses have matched a doc. There used to be a similar problem with MUST_NOT clauses, which is described in <a href='https://issues.apache.org/jira/browse/LUCENE-3510'>LUCENE-3510</a>. In a word, such design is not flexible enough, and may cost some time to scan un-hit documents (ie. those documents not matchs all MUST clauses).</p>
<p>My idea is to group up all MUST clauses so that it looks like there is just one MUST clause. For example:</p>
<div class='code'><code style='border:1px dashed gray;padding:10px;border-radius:10px;margin-top:5px;margin-bottom:5px;background-color:#ecf5ff;display:table;'>
a +b c -d +e f &lt;=&gt; +(+b +e) a c f -d
</code></div>
<p>Apparently, the left part and the right part above are just the same BooleanQuery.</p>
<p>However, when it comes to implementing, there is in fact no need to build a new BooleanClause for the MUST clauses in the query. One of the most natural ways is to pass a new ConjunctionScorer to BooleanScorer. The ConjunctionScorer represents all the MUST clauses in the query, and meanwhile, it looks like only one MUST clause.</p>
<p>Another implementing plan is to pass all required scorers as a List to BooleanScorer, and do the similar thing as first plan in BooleanScorer.</p>
<p>Both plans have advantages and disadvantages, and it is worth to explore both.</p>
</div>

<h4>2) How to collect documents in the method .score()?</h4>
<div class='h4_content'>
<p>In order to collect documents efficiently, documents collected by the ConjunctionScorer should be linked up in the bucket table firstly. After that, the linked list in the bucket table would be a list of documents which satisfy all MUST clauses. <b>ATTENTION</b>: <u>docIDs in the linked list should be in ascending order.</u></p>
<p>Then, by scanning the linked list, subScorers can check the docID and either set its MUST_NOT bit or add one SHOULD hit count to it. In this step, subScorers' .advance() method should be used to skip a lot of docIDs.</p>
<p>At last, a bucket collector can collect all target docIDs, by scanning the linked list.</p>
<p>A sketch on how to implement procedures above, is as follows:</p>
<div class='code'><code style='border:1px dashed gray;padding:10px;border-radius:10px;margin-top:5px;margin-bottom:5px;background-color:#ecf5ff;display:table;'><ol>
<li><b>for each</b> window <b>do</b></li>
<li><div style='margin-left:2em'>Collect documents within the window range as a linked list on bucket table with ConjunctionScorer;</div></li>
<li><div style='margin-left:2em'><b>for each</b> subScorer <b>do</b></div></li>
<li><div style='margin-left:4em'>currentDocID = bucketTable.firstDocID;</div></li>
<li><div style='margin-left:4em'><b>while</b> subScorer.docID() in the window <b>and</b> currentDocID is valid <b>do</b></div></li>
<li><div style='margin-left:6em'>subScorer.advance(currentDocID)</div></li>
<li><div style='margin-left:6em'><b>if</b> subScorer.docID() == currentDocID <b>then</b></div></li>
<li><div style='margin-left:8em'>Set MUST_NOT bit or add SHOULD hit count according to subScorer's type;</div></li>
<!--
<li><div style='margin-left:8em'>currentDocID = next(currentDocID);</div></li>
<li><div style='margin-left:6em'><b>else</b></div></li>
<li><div style='margin-left:8em'>currentDocID = advance(subScorer.docID());</div></li>
-->
<li><div style='margin-left:6em'><b>endif</b></div></li>
<li><div style='margin-left:6em'>currentDocID = next(currentDocID);</div></li>
<li><div style='margin-left:4em'><b>endwhile</b></div></li>
<li><div style='margin-left:2em'><b>endfor</b></div></li>
<li><div style='margin-left:2em'>Scan the linked list to collect matched docIDs;</div></li>
<li><b>endfor</b></li>
</ol></code></div>
</div>

<h4>3) Anything else to be careful?</h4>
<div class='h4_content'>
<p>Code should be specified for the situation where there is no MUST clause in BooleanQuery.</p>
</div>

<h3>How can BooleanScorer act as Sub-Scorer</h3>
In <a href='#part2'>last part</a>, I have proposed a mechanism for BooleanScorer to support MUST clauses.</p>
<p>It is amazing that, that mechanism can make those collected docIDs keep ascending order. It means that .advance(), .nextDoc() and other methods for embedded scorer can be now implemented naturally. In a word, BooleanScorer can act as Sub-Scorer, if it has MUST clauses to deal with.</p>
<p>Some of the most important methods will be described in detail below.

<h4>1) .advance()?</h4>
<div class='h4_content'>
<p>The method .advance(target) is used to advances to the first beyond the current whose document number is greater than or equal to target, and returns the document number itself.</p>
<p>The method .advance(target) is used to skip to target docID, its sketch is as follows:</p>
<div id='code2' class='code'><code style='border:1px dashed gray;padding:10px;border-radius:10px;margin-top:5px;margin-bottom:5px;background-color:#ecf5ff;display:table;'><ol>
<li><b>if</b> target &le; currentDocID <b>then</b>
<li><div style='margin-left:2em'><b>return</b> currentDocID;</div></li>
<li><b>endif</b></li>
<li><b>while</b> target &gt; largestDocID(window) <b>then</b></li>
<li><div style='margin-left:2em'>required.advance(<b>max</b>(target, largestDocID(window) + 1);</div></li>
<li><div style='margin-left:2em'><b>if</b> requried.noMore() <b>then</b></div></li>
<li><div style='margin-left:4em'><b>return</b> currentDocID = NO_MORE_DOCS;</div></li>
<li><div style='margin-left:2em'><b>endif</b></div></li>
<li><div style='margin-left:2em'>Build linked list on the 2K window beginning at required.docID();</div></li>
<li><b>endwhile</b></li>
<li><b>return</b> currentDocID = bucketTable[target &amp; <i>MASK</i>].docID;
</ol></code></div>
</div>

<h3>Improve the Rule for Choosing Scorer</h3>
<p>Relevant code to improve is in BooleanQuery.BooleanWeight.score(). What to do is to adjust the condition on returning BooleanScorer.</p>
<p>It seems that, when the BooleanScorer acts as Top Scorer, it would not perform worse than BooleanScorer2, because the tricky calling on the .advance() can skip documents as many as BooleanScorer2 does.</p>
<p>However, when BooleanScorer acts as a Sub-Scorer, it may perform worse than BooleanScorer2. This is because BooleanScorer would calculate all docIDs in a 2K window every time the current window misses a requested docID. And those docIDs in the window may actually not all useful.</p>
<p>This is one of the cases where BooleanScorer would calculate a lot of useless data.</p>

<div id='figure1' class='table_div' style='display:table'>
<div class='code'><code style='border:1px dashed gray;padding:10px;border-radius:10px;margin-top:5px;margin-bottom:5px;background-color:#ecf5ff;display:table;'>
------- |--window-#1--|--window-#2--|--window-#3--|--window-#4--|<br/>
------- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br/>
Scorer1 |-Y-----------|-------------|--Y----------|--Y----------|<br/>
------- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br/>
Scorer2 |-Y--Y---Y-Y--|--Y--Y--Y--Y-|--Y-Y-Y-Y--Y-|--YY-Y--Y-Y--|<br/>
------- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br/>
Conjunc |-Y-----------|-------------|--Y----------|--Y----------|<br/>
------- +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+<br/>
</code></div>
<div class='tag' style='text-align:center;font-weight:bold;'>Figure 1.&nbsp;&nbsp;A case where it performs not well when Scorer2 is BooleanScorer</div>
</div>
<p>Window #i represents the i-th bucket window dealed by BooleanScorer and each line lead by a scorer represents whether each document is hit by this scorer. 'Y' represents that document is hit, while '-' represents not.</p>
<p>Assume that we want to make a conjunction from Scorer1 and Scorer2. If Scorer2 is a BooleanScorer, it would cost a lot on calculating all documents hit by Scorer2 in window #1,#3,#4. However, it's apparent that most documents on bucketTable #1,#3,#4 are useless; that is to say, BooleanScorer does a lot of useless works in this case.</p>
<p>In order to prevent this, it's worth putting forward a rule for choosing which Scorer to be applied.</p>
<p>By observing the example as <a href='#figure1'>Figure 1</a> shows, we can discover that when a query, which will be used for conjunction, hits a lot of documents, it would be better to not choose BooleanScorer, but BooleanScorer2.</p>
<p>A sketch would be something as follows:</p>
<div id='code3' class='code'><code style='border:1px dashed gray;padding:10px;border-radius:10px;margin-top:5px;margin-bottom:5px;background-color:#ecf5ff;display:table;'><ol>
<li><b>if</b> required == <b>null and</b> !scoreDocsInOrder <b>and</b> topScorer <b>then</b></li>
<li><div style='margin-left:2em'><b>return new</b> BooleanScorer(<b>null</b>, optional, prohibited);</div></li>
<li><b>endif</b></li>
<li><b>if</b> required == <b>null then</b></li>
<li><div style='margin-left:2em'><b>return new</b> BooleanScorer2(required, optional, prohibited);
<li><b>endif</b></li>
<li>cScorer = <b>new</b> ConjunctionScorer(required);</li>
<li><b>if</b> minNrShouldMatch * log &alpha; + log(required.cost()) &lt; &gamma; <b>then</b></li>
<li><div style='margin-left:2em'><b>return new</b> BooleanScorer(cScorer, optional, prohibited);</div></li>
<li><b>endif</b></li>
<li><b>return</b> BooleanScorer2(required, optional, prohibited);
</ol></code></div>
</div>
<p>The condition "minNrShouldMatch * log &alpha; + log(required.cost()) &lt; &gamma;" is drived as follows:</p>
<p>required.cost() is generally an upper bound of the number of documents required clauses might match, and I assume that the number of matched documents would have a (1 - &alpha;) discount every time minNrShouldMatch increases by 1.</p>
<p>Then, the estimated number of matched documents is "required.cost() * &alpha; ^ minNrShouldMatch". Take its logarithm, ant it would be "minNrShouldMatch * log &alpha; + log(required.cost())".</p>
<p>Personally, I would guess that &alpha; is about 90%. However, a better value needs more experiments to be determined.</p>
<p>The value of &gamma; needs a lot of experiments to be determined.</p>


<!--<p>It seems that, in most situations, the improved BooleanScorer performs better than BooleanScorer2. If that is true, just clear the condition of required.size() and minNrShouldMatch.</p>
<p>However, I would like to figure out a more accurate rule. To do this, the code would be as follows:</p>
<div id='code3' class='code'><code style='border:1px dashed gray;padding:10px;border-radius:10px;margin-top:5px;margin-bottom:5px;background-color:#ecf5ff;display:table;'><ol>
<li>cScorer = <b>new</b> ConjunctionScorer(this, required);</li>
<li><b>if</b> !scoreDocsInOrder <b>and</b> topScorer <b>then</b></li>
<li><div style='margin-left:2em'><b>if</b> cScorer.cost() &lt; ?x <b>and</b> minNrShouldMatch &lt; ?y <b>then</b></div></li>
<li><div style='margin-left:4em'><b>return new</b> BooleanScorer(cScorer, required, optional, prohibited);</div></li>
<li><div style='margin-left:2em'><b>endif</b></div></li>
<li><b>endif</b></li>
</ol></code></div>
</div>
<p>By testing the benchmarks with different ?x and ?y, I can find a better rule for choosing suitable scoreer.</p>
-->

<!--<h3>Improve .rewrite() in BooleanQuery</h3>
As Only Top Scorer.-->
<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>

<h2>Reference</h2><ol>
<li>Relevant discussion on mailing list: <a href='http://mail-archives.apache.org/mod_mbox/lucene-dev/201403.mbox/%3CCAL8PwkZ0Pp+VYDSzsPXrZJx3fYKeUbxn7UUEM6v5RUzZkOvTCg@mail.gmail.com%3E'>http://mail-archives.apache.org/mod_mbox/lucene-dev/201403.mbox/%3CCAL8PwkZ0Pp+VYDSzsPXrZJx3fYKeUbxn7UUEM6v5RUzZkOvTCg@mail.gmail.com%3E'</a></li>
<li>Relevant discussion on JIRA: <a href='https://issues.apache.org/jira/browse/LUCENE-4396'>https://issues.apache.org/jira/browse/LUCENE-4396</a>.
<li>A study on the performance of BooleanScorer and BooleanScorer2: <a href='http://unreasonableeffectivenessofdata.blogspot.com/2010/05/booleanscorer-vs-booleanscorer2.html'>http://unreasonableeffectivenessofdata.blogspot.com/2010/05/booleanscorer-vs-booleanscorer2.html</a></li>
</ol>

<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>


<h2>Schedule</h2>
<p> My schedule is showed on Table 2. Being a student, I will have three exams at the end of this semester (June). It will take me some time, but I promise everything will follow the schedule.</p>
<div class='table_div' style='display:table'>
<div class='tag' style='text-align:center;font-weight:bold;'>Table 2.&nbsp;&nbsp;Project Schedule</div>
<table style='border:1px solid'>
<tr><th style='border:1px solid;'>Timeline</th><th style='border:1px solid;'>Tasks</th></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px'>April 21 - May 16</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px;' class='paragraph_td'>
<p>- Get to know more about the code.</p>
<p>- Discuss with the mentor about some confusing details on the code.</p>
<p>- Get familiar with the testing platform, <a href='https://code.google.com/a/apache-extras.org/p/luceneutil/?redir=1'>luceneutil</a>.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px'>May 17 - May 23</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px' class='paragraph_td'>
<p>- Make the BooleanScorer support MUST clauses friendly.</p>
<p>- Adjust the BooleanQuery to let BooleanScorer be applied as long as it requires a Top Scorer.</p>
<p>- Test on luceneutil to see the performance changes.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px'>May 24 - June 12</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px' class='paragraph_td'>
<p>- Implement .advance(), .nextDoc(), and other unsupported methods for BooleanScorer.</p>
<p>- Adjust the BooleanQuery to let BooleanScorer be applied in all conditions.</p>
<p>- Test on luceneutil to see the performance changes.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px'>June 13 - June 22</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px' class='paragraph_td'>
<p>- Arrange the documents for mid-term evaluations.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px;background-color:#ffffcc' class='important'>June 23 - June 25</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px;background-color:#ffffcc' class='paragraph_td important'>
<p>- Submit mid-term evaluations.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px'>June 26 - July 19</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px' class='paragraph_td'>
<p>- With the <a href='#code3'>code in last part</a>, do tests on banchmark with different arguments.</p>
<p>- Analyze the test result and figure out the best arguments.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px'>July 20 - July 31</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px' class='paragraph_td'>
<p>- Do more tests to assure the correctness and check the code.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px'>August 1 - August 10</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px' class='paragraph_td'>
<p>- Arrange the documents for reports.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px'>August 11 - August 17</td>
<td style='border:1px solid;vertical-align:middle;text-align:left;padding-left:10px;padding-right:10px' class='paragraph_td'>
<p>- Scrub code, write tests, improve documentation, etc.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px;background-color:#ffffcc' class='important'>August 18 - August 20</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px;background-color:#ffffcc' class='paragraph_td important'>
<p>- Submit final evaluations.</p>
</td></tr>
<tr>
<td style='border:1px solid;vertical-align:middle;text-align:center;padding-left:10px;padding-right:10px;background-color:#ffffcc' class='important'>August 22 - August 23</td>
<td style='border:1px solid;text-align:left;padding-left:10px;padding-right:10px;background-color:#ffffcc' class='paragraph_td important'>
<p>- Submit required code samples to Google. </p>
</td></tr>
</table>
</div>

<div class='dividor' style='height:0;border:1px solid gray;margin-top:20px;margin-bottom:20px;'></div>

<h2>About Me</h2>
<p>I am studying for my Master Degree in Peking University, where I am majoring in Search Engine &amp; Web Mining. In this semester, I am also trying to build a search engine with C++. You can fetch the newest version of my code from <a href='https://github.com/Da-Huang/Search-Engine' target='_blank'>https://github.com/Da-Huang/Search-Engine</a>.</p>

<p>You can know more about me on <a href=http://www.linkedin.com/profile/view?id=308789048 target='_blank'>http://www.linkedin.com/profile/view?id=308789048</a>.</p>

</body>

<!-- CSS -->
<style type='text/css'>
/*
* {
	font-family:monospace;
    text-align:justify;  
	text-justify:distribute-all-lines;
}
td,th {
	text-align:center;
	padding-left:10px;
	padding-right:10px;
}
div.dividor {
	border:1px solid gray;
	margin-top:20px;
	margin-bottom:20px;
}
div.tag {
	text-align:center;
	font-weight:bold;
}
td>p {
	margin:5px;
}
td.paragraph_td {
	text-align:left;
}
td.important,th.important {
	background-color:#ffffcc;
}
div.table_div {
	display:table;
	margin-top:20px;
}
p.sub1 {
	text-indent:2em;
	margin:5px;
}
h4 {
	text-indent:2em;
	margin-bottom:0;
}
div.h4_content>p {
	margin:5px;
	margin-left:2em;
	text-indent:2em;
}
table {
	margin-bottom:10px;
}
div.code {
	border:1px dashed gray;
	padding:10px;
	border-radius:10px;
	margin-top:5px;
	margin-bottom:5px;
	background-color:#ecf5ff;
	display:table;
}
div.h4_content>div.code {
	margin-left:2em;
}
code>ol {
	margin:0;
}*/
</style>
