<p>Proposal Title: BooleanScorer should sometimes be used for MUST clauses in Lucene</p>
<div class='dividor'></div>
<p>Student Name: Da Huang</p>
<p>Student E-mail: dhuang.cn@gmail.com</p>
<p>Student Mobile: +8613718862905</p>
<div class='dividor'></div>
<p>Organization/Project: The Apache Software Foundation (ASF)
<p>Assigned Mentor:</p>

<div class='dividor'></div>

<h2>Introduction to the Project</h2>
<p>Boolean Query is one of the most important types of query in an Information Retrieval System. Lucene has done several optimizations for that. The kernel modular to implement Boolean Query in lucene is <b>Scorer</b>, which can not only score a document, but also provide methods for collecting Hit Documents. There are mainly two Scorers, <b>BooleanScorer</b> and <b>BooleanScorer2</b> (Their natures can be found in <a href='#table1'>Table 1</a>), to deal with Boolean Query on current trunk. The class BooleanQuery would choose one of them as the scorer returning to the its caller.</p>
<p>Today lucene <b>only</b> uses BooleanScorer if the query consists of SHOULD and MUST_NOT. If there is one or more MUST clauses lucene always uses BooleanScorer2. But such way to make the choice is too easy and naive. What I would like to do in this project is to develop a more clever way for BooleanQuery to choose which Scorer to be uses.</p>
<p>The key to implementing the project is to make <b>BooleanScorer</b> support MUST clause, and then check the influence of MUST clause on BooleanScorer's speed by testing.</p>

<div class='dividor'></div>

<h2>Project Goals</h2>
<p>The project shall deliver three components as follows:</p>
<p class=sub1>1) BooleanScorer which supports MUST clause friendly i.e. <b>.advance()</b> should be used trickly to skip docs.</p>
<p class=sub1>2) A better rule for BooleanQuery to choose Scorer.</p>
<!--<p class=sub1>3) A better <b>.rewrite()</b> method in BooleanQuery.</p>-->
<p class=sub1>3) Revelant Javadocs and reports.</p>

<div class='dividor'></div>

<h2>Quantifiable Results for the Apache Community</h2>
<p class=sub1>1) Faster BooleanQuery for lucene.</p>
<!--<p class=sub1>2) More powerful and efficient BooleanScorer which supports .</p>
-->
<div class='dividor'></div>

<h2>Project Details</h2>
<h3>BooleanScorer vs. BooleanScorer2</h3>
Beforing getting down to the optimation, I would like analyze the two Scorers first.
<div class='table_div'>
<div id='table1' class='tag'>Table 1.&nbsp;&nbsp;BooleanScorer vs. BooleanScorer2 on current lucene trunk</div>
<table border='1'>
<tr><th>Scorer</th>
<th>Usability</th><th>Disjunction Query</th><th>Conjunction Query</th>
<th>MUST Clause</th>
</tr>
<tr><th>BooleanScorer</th>
<td>As Top Scorer Only</td><td>Faster</td><td>Not Supported Now</td><td>Used to, Not Now</td>
</tr>
<tr><th>BooleanScorer2</th>
<td>No Level Limitation</td><td>Slower</td><td>Fast</td><td>Yes</td>
</tr>
</table>
</div>
<p>Table 1 illustrates some important natures of BooleanScorer and BooleanScorer2 on the current lucene trunk. The great difference between these two Scorer is due to their different ideas on implementation:</p>
<p class=sub1>1) BooleanScorer is implemented by using an array to score windows of 2K. This way can make Disjunction Query faster, but leave the docIDs out of order as result. Thus, BooleanScorer can <b>only</b> be as Top Scorer.</p>
<p class=sub1>2) BooleanScorer2 is implemented in a much more "tranditional" way. That is merging the Disjunction Query with a heap.</p>
<p>In a conclusion, BooleanScorer applies a tricky algorithm to make Disjunction Query faster, but the algorithm makes the BooleanScorer can <b>only</b> be as Top Scorer and unsuitable for Conjunction Query.</p>
<p>As for the Top Scorer only problem, it is not a severe one, because most BooleanQuery does not have deep levels, and the costest Scorer is the Top Scorer. Thus, I prepare to solve the MUST clause.</p>

<h3>Make BooleanScorer Support MUST Clause</h3>
In order to implement this function, the following problem should be solved:
<h4>1) How many MUST clause should BooleanScorer support?</h4>
<div class='h4_content'>
<p>Actually, </p>
</div>
<h4>2) How to collect documents in the method .score()?</h4>
<div class='h4_content'>
<p></p>
</div>

<h3>Improve the Rule to Choose Scorer</h3>


<!--<h3>Improve .rewrite() in BooleanQuery</h3>
As Only Top Scorer.-->

<div class='dividor'></div>


<h2>Schedule</h2>
<p> My schedule is showed on Table 2. Being a student, I will have three exams at the end of this semester (June-July). It will take me some time, but I promise everything will follow the schedule.</p>
<div class='table_div'>
<div class='tag'>Table 2.&nbsp;&nbsp;Project Schedule</div>
<table border='1' style='text-align:center;'>
<tr><th>Timeline</th><th>Tasks</th></tr>
<tr>
<td>April 22 - May 16</td>
<td class='paragraph_td'>
<p>- Get to know more about the code.</p>
<p>- Discuss with the mentor about some details on the code.</p>
<p>- Fix bugs on the original plan.</p>
</td></tr>
<tr>
<td>May 19 - May 24</td>
<td class='paragraph_td'>
<p>- Analyze .</p>
</td></tr>
<tr>
<td>May 25 - May 31</td>
<td class='paragraph_td'>
<p>- Verify if all data is available in the Lucene index. Add what is missing.</p>
</td></tr>
<tr>
<td>June 1 - June 20</td>
<td class='paragraph_td'>
<p>- Define and implement the new scoring class hierarchy.</p>
<p>- Identify which parts of the code requires refactoring to comply with the new architecture; refactor.</p>
</td></tr>
<tr>
<td class='important'>June 18 - June 27</td>
<td class='paragraph_td important'>
<p>- Mid-term evaluations.</p>
</td></tr>
<tr>
<td>June 28 - July 19</td>
<td class='paragraph_td'>
<p>- Convert the Lucene VSM ranking algorithm to the new architecture.</p>
<p>- Test the new VSM implementation and validate it against the old one.</p>
</td></tr>
<tr>
<td>July 20 - July 31</td>
<td class='paragraph_td'>
<p>- Implement the configuration interface.</p>
</td></tr>
<tr>
<td>August 1 - August 10</td>
<td class='paragraph_td'>
<p>- Implement and test the BM25, BM25F and DFR ranking schemes.</p>
</td></tr>
<tr>
<td>August 16 - August 21</td>
<td class='paragraph_td'>
<p>- scrub code, write tests, improve documentation, etc.</p>
</td></tr>
<tr>
<td class='important'>August 22 - August 23</td>
<td class='paragraph_td important'>
<p>- submit required code samples to Google. </p>
</td></tr>
</table>
</div>

<div class='dividor'></div>

<h2>About Me</h2>
<p>I am studying for my Master Degree in Peking University, where I am majoring in Search Engine &amp; Web Mining. In this semester, I am also trying to build a search engine with C++. You can fetch the newest version of my code from <a href='https://github.com/Da-Huang/Search-Engine' target='_blank'>https://github.com/Da-Huang/Search-Engine</a>.</p>

<p>You can know more about me on <a href=http://www.linkedin.com/profile/view?id=308789048 target='_blank'>http://www.linkedin.com/profile/view?id=308789048</a>.</p>


<!-- CSS -->
<style type='text/css'>
* {
	font-family:monospace;
    text-align:justify;  
	text-justify:distribute-all-lines;
}
td,th {
	text-align:center;
	padding-left:10px;
	padding-right:10px;
}
div.dividor {
	border:1px solid gray;
	margin-top:20px;
	margin-bottom:20px;
}
div.tag {
	text-align:center;
	font-weight:bold;
}
td>p {
	margin:5px;
}
td.paragraph_td {
	text-align:left;
}
td.important,th.important {
	background-color:#ffffcc;
}
div.table_div {
	display:table;
	margin-top:20px;
}
p.sub1 {
	text-indent:2em;
	margin:5px;
}
h4 {
	text-indent:2em;
	margin-bottom:0;
}
div.h4_content>p {
	margin:5px;
	margin-left:2em;
	text-indent:2em;
}
table {
	margin-bottom:10px;
}
</style>
